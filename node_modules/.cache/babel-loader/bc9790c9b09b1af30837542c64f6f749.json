{"ast":null,"code":"/**\n * Module dependencies\n */\nvar util = require('util');\n\nvar Readable = require('stream').Readable;\n/**\n * expose\n * @ignore\n */\n\n\nmodule.exports = exports = GridReadStream;\n/**\n * GridReadStream\n *\n * @param {Grid} grid\n * @param {Object} options\n */\n\nfunction GridReadStream(grid, options) {\n  if (!(this instanceof GridReadStream)) return new GridReadStream(grid, options);\n  Readable.call(this);\n  this._opened = false;\n  this._opening = false;\n  this._closing = false;\n  this._end = false;\n  this._needToPush = false;\n  this._grid = grid; // a bit backwards compatible\n\n  if (typeof options === 'string') {\n    options = {\n      filename: options\n    };\n  }\n\n  this.options = options || {};\n\n  if (options._id) {\n    this.id = grid.tryParseObjectId(options._id);\n\n    if (!this.id) {\n      this.id = options._id;\n    }\n  }\n\n  this.name = this.options.filename || '';\n  this.mode = 'r'; // If chunk size specified use it for read chunk size otherwise default to 255k (GridStore default). chunkSize and chunk_size in mongodb api so check both.\n\n  this._chunkSize = this.options.chunkSize || this.options.chunk_size || 1024 * 255;\n  this.range = this.options.range || {\n    startPos: 0,\n    endPos: undefined\n  };\n\n  if (typeof this.range.startPos === 'undefined') {\n    this.range.startPos = 0;\n  }\n\n  this._currentPos = this.range.startPos;\n  var options = {};\n\n  for (var i in this.options) {\n    options[i] = this.options[i];\n  }\n\n  options.root || (options.root = this._grid.curCol);\n  this._store = new grid.mongo.GridStore(grid.db, this.id || new grid.mongo.ObjectID(), this.name, this.mode, options); // Workaround for Gridstore issue https://github.com/mongodb/node-mongodb-native/pull/930\n\n  if (!this.id) {\n    // var REFERENCE_BY_FILENAME = 0,\n    this._store.referenceBy = 0;\n  }\n\n  var self = this; //Close the store once `end` received\n\n  this.on('end', function () {\n    self._end = true;\n\n    self._close();\n  });\n  process.nextTick(function () {\n    self._open();\n  });\n}\n/**\n * Inherit from stream.Readable\n * @ignore\n */\n\n\nutil.inherits(GridReadStream, Readable);\n/**\n * _open\n *\n * @api private\n */\n\nGridReadStream.prototype._open = function _open() {\n  if (this._opening) return;\n  this._opening = true;\n  var self = this; // Open the sore\n\n  this._store.open(function (err, gs) {\n    if (err) return self._error(err); // Find the length of the file by setting the head to the end of the file and requesting the position\n\n    self._store.seek(0, self._grid.mongo.GridStore.IO_SEEK_END, function (err) {\n      if (err) return self._error(err); // Request the position of the end of the file\n\n      self._store.tell(function (err, position) {\n        if (err) return self._error(err); // Calculate the correct end position either from EOF or end of range. Also handle incorrect range request.\n\n        if (!self.range.endPos || self.range.endPos > position - 1) {\n          self.range.endPos = position - 1;\n        }\n\n        ; // Set the read head to the beginning of the file or start position if specified\n\n        self._store.seek(self.range.startPos, self._grid.mongo.GridStore.IO_SEEK_SET, function (err) {\n          if (err) return self._error(err); // The store is now open\n\n          self.emit('open');\n          self._opened = true; // If `_read()` was already called then we need to start pushing data to the stream. Otherwise `_read()` will handle this once called from stream.\n\n          if (self._needToPush) self._push();\n        });\n      });\n    });\n  });\n};\n/**\n * _read\n *\n * @api private\n */\n// `_read()` will be called when the stream wants to pull more data in\n// The advisory `size` argument is ignored in this case and user specified use or default to 255kk.\n\n\nGridReadStream.prototype._read = function _read(size) {\n  var self = this; // Set `_needToPush` to true because the store may still be closed if data is immediately piped. Once the store is open `_needToPush` is checked and _push() called if necessary.\n\n  self._needToPush = true; // The store must be open\n\n  if (!this._opened) return; // Read data from GridStore and push to stream\n\n  self._push();\n};\n/**\n * _push\n *\n * @api private\n */\n\n\nGridReadStream.prototype._push = function _push() {\n  var self = this; // Do not continue if the store is closed\n\n  if (!this._opened) return self._error('Unable to push data. Expected gridstore to be open'); // Check if EOF, if the full requested range has been pushed or if the stream must be destroyed. If so than push EOF-signalling `null` chunk\n\n  if (!this._store.eof() && self._currentPos <= self.range.endPos && !this._end) {\n    // Determine the chunk size for the read from GridStore\n    // Use default chunk size or user specified\n    var readChunkSize = self._chunkSize; // Override the chunk size if the chunk size is more than the size that is left until EOF/range\n\n    if (self.range.endPos - self._currentPos < self._chunkSize) {\n      readChunkSize = self.range.endPos - self._currentPos + 1;\n    }\n\n    ; // Read the chunk from GridSore. Head moves automatically after each read.\n\n    self._store.read(readChunkSize, function (err, data) {\n      // If error stop and close the store\n      if (err) return self._error(err); // Advance the current position of the read head\n\n      self._currentPos += data.length; // Push data\n\n      if (!self._end) self.push(data);\n    });\n  } else {\n    // Push EOF-signalling `null` chunk\n    this._end = true;\n    self.push(null);\n  }\n};\n/**\n * _close\n *\n * @api private\n */\n\n\nGridReadStream.prototype._close = function _close() {\n  var self = this;\n  if (!self._opened) return;\n  if (self._closing) return;\n  this._closing = true; // Close the store and emit `close` event\n\n  self._store.close(function (err) {\n    if (err) return self._error(err);\n    self.emit('close');\n  });\n};\n/**\n * _error\n *\n * @api private\n */\n\n\nGridReadStream.prototype._error = function _error(err) {\n  // Set end true so that no further reads from GridSotre are possible and close the store\n  this._end = true; // Emit the error event\n\n  this.emit('error', err); // Close the gridsore if an error is received.\n\n  this._close();\n};\n/**\n * destroy\n *\n * @api public\n */\n\n\nGridReadStream.prototype.destroy = function destroy() {\n  // Set end true so that no further reads from GridSotre are possible and close the store\n  this._end = true;\n\n  this._close();\n};","map":null,"metadata":{},"sourceType":"script"}