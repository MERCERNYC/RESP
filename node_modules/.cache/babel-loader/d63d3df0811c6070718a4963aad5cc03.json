{"ast":null,"code":"/**\n * Module dependencies\n */\nvar util = require('util'); //var Writable  = require('stream').Writable;\n// This is a workaround to implement a _flush method for Writable (like for Transform) to emit the 'finish' event only after all data has been flushed to the underlying system (GridFS). See https://www.npmjs.com/package/flushwritable and https://github.com/joyent/node/issues/7348\n\n\nvar FlushWritable = require('flushwritable');\n/**\n * expose\n * @ignore\n */\n\n\nmodule.exports = exports = GridWriteStream;\n/**\n * GridWriteStream\n *\n * @param {Grid} grid\n * @param {Object} options (optional)\n */\n\nfunction GridWriteStream(grid, options) {\n  if (!(this instanceof GridWriteStream)) return new GridWriteStream(grid, options);\n  FlushWritable.call(this);\n  this._opened = false;\n  this._opening = false;\n  this._writable = true;\n  this._closing = false;\n  this._destroyed = false;\n  this._errorEmitted = false;\n  this._grid = grid; // a bit backwards compatible\n\n  if (typeof options === 'string') {\n    options = {\n      filename: options\n    };\n  }\n\n  this.options = options || {};\n\n  if (this.options._id) {\n    this.id = grid.tryParseObjectId(this.options._id);\n\n    if (!this.id) {\n      this.id = this.options._id;\n    }\n  }\n\n  this.name = this.options.filename; // This may be undefined, that's okay\n\n  if (!this.id) {\n    //_id not passed or unparsable? This is a new file!\n    this.id = new grid.mongo.ObjectID();\n    this.name = this.name || ''; // A new file needs a name\n  }\n\n  this.mode = 'w'; //Mongodb v2 driver have disabled w+ because of possible data corruption. So only allow `w` for now.\n  // The value of this.name may be undefined. GridStore treats that as a missing param\n  // in the call signature, which is what we want.\n\n  this._store = new grid.mongo.GridStore(grid.db, this.id, this.name, this.mode, this.options);\n  this._delayedWrite = null;\n  this._delayedFlush = null;\n  this._delayedClose = null;\n  var self = this;\n\n  self._open();\n}\n/**\n * Inherit from stream.Writable (FlushWritable for workaround to defer finish until all data flushed)\n * @ignore\n */\n\n\nutil.inherits(GridWriteStream, FlushWritable); // private api\n\n/**\n * _open\n *\n * @api private\n */\n\nGridWriteStream.prototype._open = function () {\n  if (this._opened) return;\n  if (this._opening) return;\n  this._opening = true;\n  var self = this;\n\n  this._store.open(function (err, gs) {\n    self._opening = false;\n    if (err) return self._error(err);\n    self._opened = true;\n    self.emit('open'); // If _close was called during _store opening, then it was delayed until now, so do the close now\n\n    if (self._delayedClose) {\n      var closed = self._delayedClose.cb;\n      self._delayedClose = null;\n      return self._closeInternal(closed);\n    } // If _flush was called during _store opening, then it was delayed until now, so do the flush now (it's necessarily an empty GridFS file, no _write could have been called and have finished)\n\n\n    if (self._delayedFlush) {\n      var flushed = self._delayedFlush;\n      self._delayedFlush = null;\n      return self._flushInternal(flushed);\n    } // If _write was called during _store opening, then it was delayed until now, so do the write now (_flush could not have been called yet as _write has not finished yet)\n\n\n    if (self._delayedWrite) {\n      var delayedWrite = self._delayedWrite;\n      self._delayedWrite = null;\n      return self._writeInternal(delayedWrite.chunk, delayedWrite.encoding, delayedWrite.done);\n    }\n  });\n};\n/**\n * _writeInternal\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._writeInternal = function (chunk, encoding, done) {\n  // If destroy or error no more data will be written.\n  if (!this._writable) return;\n  var self = this; // Write the chunk to the GridStore. The write head automatically moves along with each write.\n\n  this._store.write(chunk, function (err, store) {\n    if (err) return self._error(err); // Emit the write head position\n\n    self.emit('progress', store.position); // We are ready to receive a new chunk from the writestream - call done().\n\n    done();\n  });\n};\n/**\n * _write\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._write = function (chunk, encoding, done) {\n  if (this._opening) {\n    // if we are still opening the store, then delay the write until it is open.\n    this._delayedWrite = {\n      chunk: chunk,\n      encoding: encoding,\n      done: done\n    };\n    return;\n  } // otherwise, do the write now\n\n\n  this._writeInternal(chunk, encoding, done);\n};\n/**\n * _flushInternal\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._flushInternal = function (flushed) {\n  this._close(flushed);\n};\n/**\n * _flush\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._flush = function (flushed) {\n  // _flush is called when all _write() have finished (even if no _write() was called (empty GridFS file))\n  if (this._opening) {\n    // if we are still opening the store, then delay the flush until it is open.\n    this._delayedFlush = flushed;\n    return;\n  } // otherwise, do the flush now\n\n\n  this._flushInternal(flushed);\n};\n/**\n * _closeInternal\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._closeInternal = function (cb) {\n  if (!this._opened) return;\n  if (this._closing) return;\n  this._closing = true;\n  var self = this;\n\n  this._store.close(function (err, file) {\n    self._closing = false;\n    self._opened = false;\n    if (err) return self._error(err);\n    self.emit('close', file);\n    if (cb) cb();\n  });\n};\n/**\n * _close\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._close = function _close(cb) {\n  if (this._opening) {\n    // if we are still opening the store, then delay the close until it is open.\n    this._delayedClose = {\n      cb: cb\n    };\n    return;\n  } // otherwise, do the close now\n\n\n  this._closeInternal(cb);\n};\n/**\n * _error\n *\n * @api private\n */\n\n\nGridWriteStream.prototype._error = function _error(err) {\n  // Stop receiving more data to write, emit `error` and close the store\n  if (this._errorEmitted) return;\n  this._errorEmitted = true;\n  this._writable = false;\n  this.emit('error', err);\n\n  this._close();\n}; // public api\n\n/**\n * destroy\n *\n * @api public\n */\n\n\nGridWriteStream.prototype.destroy = function destroy(err) {\n  // Abort the write stream, even if write not completed\n  if (this._destroyed) return;\n  this._destroyed = true;\n  var self = this;\n  process.nextTick(function () {\n    self._error(err);\n  });\n};\n/**\n * destroySoon\n *\n * @api public\n * @deprecated just use destroy()\n */\n\n\nGridWriteStream.prototype.destroySoon = function destroySoon() {\n  return this.destroy();\n};","map":null,"metadata":{},"sourceType":"script"}