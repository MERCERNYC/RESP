{"ast":null,"code":"'use strict';\n\nconst AggregationCursor = require('../aggregation_cursor');\n\nconst applyWriteConcern = require('../utils').applyWriteConcern;\n\nconst decorateWithCollation = require('../utils').decorateWithCollation;\n\nconst decorateWithReadConcern = require('../utils').decorateWithReadConcern;\n\nconst handleCallback = require('../utils').handleCallback;\n\nconst MongoError = require('mongodb-core').MongoError;\n\nconst resolveReadPreference = require('../utils').resolveReadPreference;\n\nconst toError = require('../utils').toError;\n\nconst DB_AGGREGATE_COLLECTION = 1;\n/**\n * Perform an aggregate operation. See Collection.prototype.aggregate or Db.prototype.aggregate for more information.\n *\n * @method\n * @param {Db} db A Db instance.\n * @param {Collection|string} coll A collection instance or the string '1', used for db.aggregate.\n * @param {object} [pipeline=[]] Array containing all the aggregation framework commands for the execution.\n * @param {object} [options] Optional settings. See Collection.prototype.aggregate or Db.prototype.aggregate for a list of options.\n * @param {Db~aggregationCallback|Collection~aggregationCallback} callback The command result callback\n */\n\nfunction aggregate(db, coll, pipeline, options, callback) {\n  const isDbAggregate = typeof coll === 'string';\n  const target = isDbAggregate ? db : coll;\n  const topology = target.s.topology;\n  let hasOutStage = false;\n\n  if (typeof options.out === 'string') {\n    pipeline = pipeline.concat({\n      $out: options.out\n    });\n    hasOutStage = true;\n  } else if (pipeline.length > 0 && pipeline[pipeline.length - 1]['$out']) {\n    hasOutStage = true;\n  }\n\n  let command;\n  let namespace;\n  let optionSources;\n\n  if (isDbAggregate) {\n    command = {\n      aggregate: DB_AGGREGATE_COLLECTION,\n      pipeline: pipeline\n    };\n    namespace = \"\".concat(db.s.databaseName, \".\").concat(DB_AGGREGATE_COLLECTION);\n    optionSources = {\n      db\n    };\n  } else {\n    command = {\n      aggregate: coll.s.name,\n      pipeline: pipeline\n    };\n    namespace = coll.s.namespace;\n    optionSources = {\n      db: coll.s.db,\n      collection: coll\n    };\n  }\n\n  const takesWriteConcern = topology.capabilities().commandsTakeWriteConcern;\n\n  if (!hasOutStage) {\n    decorateWithReadConcern(command, target, options);\n  }\n\n  if (pipeline.length > 0 && pipeline[pipeline.length - 1]['$out'] && takesWriteConcern) {\n    applyWriteConcern(command, optionSources, options);\n  }\n\n  try {\n    decorateWithCollation(command, target, options);\n  } catch (err) {\n    if (typeof callback === 'function') return callback(err, null);\n    throw err;\n  }\n\n  if (options.bypassDocumentValidation === true) {\n    command.bypassDocumentValidation = options.bypassDocumentValidation;\n  }\n\n  if (typeof options.allowDiskUse === 'boolean') command.allowDiskUse = options.allowDiskUse;\n  if (typeof options.maxTimeMS === 'number') command.maxTimeMS = options.maxTimeMS;\n  if (options.hint) command.hint = options.hint;\n  options = Object.assign({}, options); // Ensure we have the right read preference inheritance\n\n  options.readPreference = resolveReadPreference(options, optionSources);\n\n  if (options.explain) {\n    if (command.readConcern || command.writeConcern) {\n      throw toError('\"explain\" cannot be used on an aggregate call with readConcern/writeConcern');\n    }\n\n    command.explain = options.explain;\n  }\n\n  if (typeof options.comment === 'string') command.comment = options.comment; // Validate that cursor options is valid\n\n  if (options.cursor != null && typeof options.cursor !== 'object') {\n    throw toError('cursor options must be an object');\n  }\n\n  options.cursor = options.cursor || {};\n  if (options.batchSize && !hasOutStage) options.cursor.batchSize = options.batchSize;\n  command.cursor = options.cursor; // promiseLibrary\n\n  options.promiseLibrary = target.s.promiseLibrary; // Set the AggregationCursor constructor\n\n  options.cursorFactory = AggregationCursor;\n\n  if (typeof callback !== 'function') {\n    if (!topology.capabilities()) {\n      throw new MongoError('cannot connect to server');\n    }\n\n    return topology.cursor(namespace, command, options);\n  }\n\n  return handleCallback(callback, null, topology.cursor(namespace, command, options));\n}\n\nmodule.exports = {\n  aggregate\n};","map":null,"metadata":{},"sourceType":"script"}